<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Dash Clone</title>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script>
        let player, obstacles = [], particles = [];
        let playerSize = 50, playerX = 50, playerY, gravity = 2.6, jumpForce = 0;
        let isJumping = false, rotationAngle = 0, playerSpeed = 4, cameraX = 0;
        let score = 0, highScore = 0, groundY, gameActive = true, gameOver = false;

        function setup() {
            createCanvas(1280, 720);
            playerY = height - playerSize - 100;
            groundY = height - 100;
            textSize(45);
            textAlign(CENTER, CENTER);
        }

        function draw() {
            background(0);

            if (gameActive && !gameOver) {
                if (isJumping) {
                    playerY += jumpForce;
                    jumpForce += gravity;
                    if (playerY > height - playerSize - 100) {
                        playerY = height - playerSize - 100;
                        isJumping = false;
                        jumpForce = 0;
                    } else {
                        rotationAngle -= 5.3;
                    }
                } else {
                    playerY += gravity;
                    if (rotationAngle !== 0) rotationAngle = 0;
                }

                playerX += playerSpeed;
                cameraX = playerX - width / 7;
                generateObstacles();
                updateObstacles();
                generateParticles();
                updateParticles();

                score++;
            }

            drawGround();
            drawPlayer();
            drawObstacles();
            drawParticles();
            showScore();

            if (gameOver) showGameOverScreen();
        }

        function keyPressed() {
            if (key == ' ') {
                if (!isJumping) {
                    isJumping = true;
                    jumpForce = -20;
                }
            }
        }

        function mousePressed() {
            if (gameOver && mouseY > height / 2 + 50 && mouseY < height / 2 + 100) {
                resetGame();
            } else if (!isJumping) {
                isJumping = true;
                jumpForce = -20;
            }
        }

        function resetGame() {
            playerX = 50;
            playerY = height - playerSize - 100;
            isJumping = false;
            jumpForce = 0;
            obstacles = [];
            particles = [];
            rotationAngle = 0;
            if (score > highScore) highScore = score;
            score = 0;
            gameOver = false;
        }

        function showScore() {
            fill(255);
            text(`Score: ${score}`, 100, 50);
            text(`High Score: ${highScore}`, width - 200, 50);
        }

        function showGameOverScreen() {
            fill(255);
            textSize(100);
            text("Game Over", width / 2, height / 2 - 50);
            textSize(36);
            text("Click to Restart", width / 2, height / 2 + 100);
        }

        function drawGround() {
            stroke(255);
            strokeWeight(5);
            line(0 - cameraX, groundY, width, groundY);
        }

        function drawPlayer() {
            push();
            translate(playerX - cameraX + playerSize / 2, playerY + playerSize / 2);
            rotate(radians(rotationAngle));
            fill(255, 255, 0);
            rectMode(CENTER);
            rect(0, 0, playerSize, playerSize);
            pop();
        }

        function generateObstacles() {
            if (frameCount % 60 === 0) {
                let obstacleSize = 40;
                let obstacleY = height - obstacleSize - 62;
                let obstacleX = playerX + width;
                obstacles.push({x: obstacleX, y: obstacleY, size: obstacleSize});
            }
        }

        function updateObstacles() {
            obstacles.forEach(obstacle => {
                obstacle.x -= playerSpeed;
                if (playerX < obstacle.x + obstacle.size &&
                    playerX + playerSize > obstacle.x &&
                    playerY < obstacle.y + obstacle.size &&
                    playerY + playerSize > obstacle.y) {
                    gameOver = true;
                }
            });
            obstacles = obstacles.filter(obstacle => obstacle.x - cameraX > 0);
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                fill(0);
                stroke(255);
                strokeWeight(3);
                beginShape();
                vertex(obstacle.x - cameraX, obstacle.y);
                vertex(obstacle.x - cameraX + obstacle.size, obstacle.y);
                vertex(obstacle.x - cameraX + obstacle.size / 2, obstacle.y - obstacle.size);
                endShape(CLOSE);
            });
        }

        function generateParticles() {
            if (!isJumping && playerSpeed > 2 && particles.length < 50) {
                let particleX = playerX + playerSize / 1.4;
                let particleY = playerY + playerSize / 1.2 + random(-4, 4);
                particles.push({x: particleX, y: particleY, size: 8, alpha: 255});
            }
        }

        function updateParticles() {
            particles.forEach(particle => {
                particle.x -= playerSpeed;
                particle.y += random(-0.4, 0.4);
                particle.alpha -= 2;
            });
            particles = particles.filter(particle => particle.alpha > 0 && particle.x - cameraX > 0);
        }

        function drawParticles() {
            particles.forEach(particle => {
                fill(255, 255, 255, particle.alpha);
                noStroke();
                rect(particle.x - cameraX, particle.y, particle.size, particle.size);
            });
        }
    </script>
</body>
</html>
